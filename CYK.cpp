/*
Author:	My Tran
Filename:	CYK.cpp
Description:	Contains the definitions of the methods of CYK.h
*/
#include "CYK.h"

//default constructor
CYK::CYK(std::string in, std::string CFG)
{
	//CYK object is created with grammar and input string stored
	input = in;
	grammar = CFG;

	//Run lexing and parsing algorithm to map grammar
	ParseGrammar();
}

//Default grammar
CYK::CYK()
{
	input = nullptr;
	grammar = nullptr;
	startRule = nullptr;
}

//parses grammar input into mapping of grammar rules
void CYK::ParseGrammar()
{
	//Operations cannot be performed without a grammar to parse
	if (grammar.empty())
	{
		std::cout << "ERROR: No grammar to parse...\n";
		exit(1);
	}
	//Perform parsing on grammar to obtain mapping of rules
	else
	{
		//Lexer object has parsing method
		Lexer *parser = new Lexer(grammar);
		parser->Parse();

		//map and start members are set
		grammarMap = parser->GetMap();
		startRule = parser->GetStart();
	}
}

//initialize the size of the triangular table
void CYK::InitMatrix()
{
	//height of the triangle table should be the same as the length of the input
	triangleTable = std::vector < std::vector<std::unordered_map<std::string, Token>>>(input.length());
	
	//Rows of the table increment by one row by row
	for (auto i = 0, j = 1; i < triangleTable.size(); i++, j++)
	{
		 triangleTable[i] = std::vector<std::unordered_map<std::string, Token>>(j);
	}
}

//Runs the CYK algorithm
void CYK::Run()
{
	std::cout << "Running CYK algorithm...\n";
	
	//Set table size
	InitMatrix();

	//Fill squares in accordance to CYK algo
	FillMatrix();

	std::cout << "CYK Complete\n";
}

void CYK::FillMatrix()
{
	//fill hypotenuse edges of the triangle table
	std::cout << "Filling in outmost diagonal edges... x_ii - x_nn\n";
	for (auto i = 0; i < input.length(); i++)
	{
		//from square[0][0] to square[n][n], insert (rule, token) pair if rule terminates to input symbol on RHS
		for (const auto &pair : grammarMap)
		{
			//Find input symbol in each production rules RHS. If found, insert a pair into the triangle table
			if (pair.second.find(input.substr(i, 1)) != pair.second.end())
			{
				triangleTable[i][i][pair.first] = Token::RULE;
			}
		}
	}

	std::cout << "Populating the rest of the squares...\n";
	//Fill in the rest of the squares. Fill in the diagonals until the table is filled.
	for (auto i = 1, k = 2; i < input.length(); k++)
	{
		for (auto j = 0; i < input.length(); i++, j++)
		{
			CalculateSquare(j, i);
		}

		i = k;
	}
}

//Fill in square[row][column] of triangle table using CYK algorithm.
void CYK::CalculateSquare(int column, int row)
{
	//To store the union of cartesian products between square combinations
	std::unordered_map<std::string, Token> cartesianUnion;

	//implements CYK x_ij = {x_(i,i) x x_(i+1,j)} U {x_(i,i+1) x x_(i+2,j)} U ... U {x_(i,j-1) x x_(j,j)}
	for (auto i = column, j = column; i < row; i++, j++)
	{
		for (const auto& pair1 : triangleTable[i][column])
		{
			for (const auto& pair2 : triangleTable[row][j+1])
			{
				//Insert cartesian pair into map for comparison
				cartesianUnion[pair1.first + pair2.first] = Token::RULE;
			}
		}
	}

	//Compare all the cartesian pairs with the production rules. Add rule if the pair shows up in RHS of rule.
	for (const auto& cartPair : cartesianUnion)
	{
		for (const auto& rulePair : grammarMap)
		{
			//Insert into triangle table at square[row][column] if pair is found
			if (rulePair.second.find(cartPair.first) != rulePair.second.end())
			{
				triangleTable[row][column][rulePair.first] = Token::RULE;
			}
		}
	}

	//clear temp vector for mem management sake
	cartesianUnion.clear();
}

//Runs CYK algorithm to determine whether an input string can be generated by a CFG
bool CYK::IsAccepted()
{
	for (std::vector<std::unordered_map<std::string, Token>> v : triangleTable)
	{
		v.clear();
	}
	triangleTable.clear();

	//if the empty string is given, replace with indicated symbol for epsilon, E.
	if (input.empty())
	{
		input = "E";
	}

	//Perform CYK algorithm
	Run();

	//If the string is length 1, it can only be produced if start is found in the only square in the table
	if (input.length() == 1)
	{
		if (triangleTable[0][0].find(startRule) != triangleTable[0][0].end())
		{
			//return true if found, false otherwise
			return true;
		}
		else
		{
			return false;
		}
	}
	else
	{
		//If the string is accepted, the start rule will be found in the bottom left most square in the triangle.
		if (triangleTable[input.length() - 1][0].find(startRule) != triangleTable[input.length() - 1][0].end())
		{
			//return true if found, false otherwise
			return true;
		}
		else
		{
			return false;
		}
	}
}

//Outputs display of triangle table
void CYK::PrintTable()
{
	//for each row in the triangle table, print the columns set of rules from CYK
	for (std::vector<std::unordered_map<std::string, Token>> row : triangleTable)
	{
		//Rows have unique number of entries because of incrementing row structure as it descends down
		//std::cout << "Row " << row.size() << ":\n";
		int i = 1;
		//for each map in the square, print the contents if the map
		for (std::unordered_map<std::string, Token> column : row)
		{
			//each column contains a mapping of rules for fast searching and comparison
			std::cout << "x_" << i << "," << std::to_string(row.size()) << ": {";
			for (const auto& pair : column)
			{
				//print the elements of each map
				std::cout << "{" << pair.first << "}";
			}
			std::cout << "} | ";
			i++;
		}
		std::cout << "\n";
	}
}

//Destructor for CYK object
CYK::~CYK()
{
	//clear each row of the triangleTable
	for (std::vector<std::unordered_map<std::string, Token>> row : triangleTable)
	{
		//for each map in the square, print the contents if the map
		for (std::unordered_map<std::string, Token> column : row)
		{
			//for each column in a row, clear the associated map
			column.clear();
		}
		row.clear();
	}

	grammarMap.clear();
}

//Setter for input string stored by object
void CYK::SetInput(std::string in)
{
	input = in;
}

//Returns a string representation of the triangle table from the CYK algorithm
std::string CYK::ToString()
{
	std::string output = "";

	//for each row in the triangle table, print the columns set of rules from CYK
	for (std::vector<std::unordered_map<std::string, Token>> row : triangleTable)
	{
		//Rows have unique number of entries because of incrementing row structure as it descends down
		//output += "Row " + std::to_string(row.size()) + ":\n";
		int i = 1;
		//for each map in the square, print the contents if the map
		for (std::unordered_map<std::string, Token> column : row)
		{
			//each column contains a mapping of rules for fast searching and comparison
			output += "x_" + std::to_string(i) + "," + std::to_string(row.size()) + ": {";
			for (const auto& pair : column)
			{
				//print the elements of each map
				output+= "{" + pair.first + "}";
			}
			output+= "} | ";
			i++;
		}
		output += "\n";
	}

	return output;
}

//setter for new grammar
void CYK::SetGrammar(std::string CFG)
{
	grammar = CFG;
	
	//clears old grammar map if any
	grammarMap.clear();

	//perform parse on new grammar
	ParseGrammar();
}