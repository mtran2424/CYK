Lexer and CYK: README
-----------------------------------------------------------------------------
This is a C++ program that implements the CYK algorithm to determine
if an input string can be generated by a context-free grammar in Chomsky
Normal Form (CNF). The program runs a grammar string through a lexer and
parser that maps the grammar's production rules to it's right hand
productions, and runs the CYK algorithm on the input string for a grammar.

Requirements:
-----------------------------------------------------------------------------
This program requires a C++ compiler and the std C++ library.

Instructions and Dependencies:
-----------------------------------------------------------------------------
1. Compile the program:
	In a terminal:
	- Start up terminal in Linux or through bash on Windows via WSL
	- Ensure that g++ is installed. If not, input the following into the
	command line: "sudo apt install g++"
	- This should install the C++ compiler for Linux.
	- Create a new directory and include the following files:
		- Driver.cpp
		- Token.h
		- Lexer.cpp
		- Lexer.h
		- CYK.cpp
		- CYK.h
		- CFG.txt
		- input.txt
	- cd to the new directory and in the command line, input the following:
	"g++ -o driver.out driver.cpp Token.h Lexer.cpp Lexer.h CYK.cpp CYK.h"
	- This will create an executable file called driver.out in the directory.
	- To run the program, input inot the command line:
	"./driver.out"

	In Visual Studio:
	- Create a new C++ project and paste the following files into the project
	folder:
		- Driver.cpp
		- Token.h
		- Lexer.cpp
		- Lexer.h
		- CYK.cpp
		- CYK.h
		- CFG.txt
		- input.txt
	- In the solution explorer (Open with quick menu at the top of the screen
	by clicking on "View" and selecting "Solution Explorer"): 
	- right click on "Header Files", hover over "Add", select "Existing Item...", 
	and add all the files with the .h file extension.
	- repeat the above step with the "Source Files" folder, with the files with
	the .cpp file extension.
	- Double click the "Driver.cpp" file to open.
	- Enter the command "CRTL-F5" to compile and run.

2) Use the included "CFG.txt" file or prepare your own, and name it "CFG.txt".
The format of the file should be as follows:
	- The CFG's in the file should be in CNF to guarantee correct result
	(i.e rules in the CFG are of the form A->BC or A->a where A,B,C are
	non-terminals/variables, and a is a terminal symbol)
	- Non-terminals/Variables are denoted lone upper case letters.
	- Terminals are denoted by lone lower case letters and non-reserved symbols.
	- '|' symbols are reserved to denote OR, so rules separated by '|'
	are of the same production rule.
	- ',' symbols are reserved denote a new rule, so a comma separations denote
	new production rules.
	- CFGs are separated by a newline so each line should be a separate CFG.
	- An example of a CFG file's content is shown below:

S->AR|E,Q->AR,R->QB|b,A->a,B->b

S->QU|TR|UU|TT|BW|AV|E,Q->AV, V->QB|b, R->BW, W->RC|c, T->TT|a|E, U->UU|c|E, A->a, B->b, C->c

S->QT|AU|BV|HQ|a|b|#|E, Q->QT|AU|BV|HQ|a|b|#, R->AU|BV|a|b, T->HQ|#, U->RA|a, V->RB|b, A->a, B->b, H->#

S->TT|ZV|#, T->ZT|TZ|#, U->ZV|#, V->UW, W->ZZ, Z->0

3) Use the included "input.txt" file or prepare your own and name it "input.txt".
The format of the file should be as follows:
	- Newlines separate input strings so there should be one input string per 
	line.
	- Input strings should only consist of terminating symbols (i.e. 
	lower-case letters, non-reserved symbols)
	Reserved symbols:
	'|', 'E', ' ', '-', '>'

4) After running the program, the a file called "log.txt" will be in the same 
directory as the executable. This file contains the output of the testing program. 
The grammar the input is being tested in, the triangle table from CYK, the input 
string, and whether the string is accepted is logged to the file for each test 
input and each grammar.

Limitations:
-----------------------------------------------------------------------------
The program only works with CFGs in CNF. General CFGs are not guaranteed to 
yield a result. Inputing erroneous CFGs may also cause unexpected behavior 
with the program. Thus, the program assumes it is given valid input and the
correctness in outputs is the responsiblity of the user to provide correct
inputs.

log.txt Key 
-----------------------------------------------------------------------------
The key to the accepted and non-accepted strings in the included test file
with short justifications below:
	-accepted : denotes that the string can be generated
	-rejected : denotes that the string can not be generated

S->AR|E,Q->AR,R->QB|b,A->a,B->b
accepted : aaabbb		3:3 for a:b so in language.
accepted : aabb			2:2 for a:b so in language.
accepted : ab			1:1 for a:b so in language.
rejected : abb			1:2 for a:b. 1 != 2 so not in language.
rejected : aab			2:1 for a:b. 2 != 1 so not in language.
rejected : aaabbbb		3:4 for a:b. 3 != 4 so not in language.
rejected : abc			c's not in language.
rejected : abbcc		c's not in language.
rejected : abccc		c's not in language.
rejected : bc			c's not in language.
rejected : aabbc		c's not in language.
rejected : abcbca		c's not in language.
rejected : bab			c's not in language.
rejected : aaaabbbaaaa		Cannot have a's come after b's.
rejected : abaaa		Cannot have a's come after b's.
rejected : cbc			c's not in language.
rejected : abba			Cannot have a's come after b's.
rejected : bb			0:2 for a:b. 0 != 2 so not in language.
rejected : #			#'s not in language.
rejected : bab#aba#abba		#'s not in language.
rejected : bab#b#abab		#'s not in language.
rejected : bab#b#		#'s not in language.
rejected : 00#0000		0's, #'s not in language.
rejected : 0#000#0		0's, #'s not in language.
rejected : ##			#'s not in language.
rejected : 0000#0#0000		0's, #'s not in language.
rejected : 0##00		0's, #'s not in language.
rejected : ##00			0's, #'s not in language.
rejected : 0#0			0's, #'s not in language.
rejected : 0#000		0's, #'s not in language.
rejected : 000#0		0's, #'s not in language.
accepted : 			E is in the language. 0 a's and 0 b's.


S->QU|TR|UU|TT|BW|AV|E,Q->AV, V->QB|b, R->BW, W->RC|c, T->TT|a|E, U->UU|c|E, A->a, B->b, C->c
accepted : aaabbb		3:3:0 for a:b:c. a = b so in language.
accepted : aabb			2:2:0 for a:b:c. a = b so in language.
accepted : ab			1:1:0 for a:b:c. a = b so in language.
rejected : abb			1:2:0 for a:b:c. a != b and b != c so not in language.
rejected : aab			2:1:0 for a:b:c. a != b and b != c so not in language.
rejected : aaabbbb		3:4:0 for a:b:c. a != b and b != c so not in language.
accepted : abc			1:1:1 for a:b:c. a = b and b = c so in language.
accepted : abbcc		1:2:2 for a:b:c. b = c so in language.
accepted : abccc		1:1:3 for a:b:c. a = b so in language.
accepted : bc			0:1:1 for a:b:c. b = c so in language.
accepted : aabbc		2:2:1 for a:b:c. a = b so in language.
rejected : abcbca		a's and b's cannot come after c in language.
rejected : bab			a cannot come after b in language.
rejected : aaaabbbaaaa		a's cannot come after b's in language. 
rejected : abaaa		a's cannot come after b's in language.
rejected : cbc			b cannot come after c in language.
rejected : abba			a cannot come after b's in language.
rejected : bb			0:2:0 for a:b:c. a != b and b != c so not in language.
rejected : #			#'s not in language.
rejected : bab#aba#abba		#'s not in language.
rejected : bab#b#abab		#'s not in language.
rejected : bab#b#		#'s not in language.
rejected : 00#0000		0's, #'s not in language.
rejected : 0#000#0		0's, #'s not in language.
rejected : ##			#'s not in language.
rejected : 0000#0#0000		0's, #'s not in language.
rejected : 0##00		0's, #'s not in language.
rejected : ##00			0's, #'s not in language.
rejected : 0#0			0's, #'s not in language.
rejected : 0#000		0's, #'s not in language.
rejected : 000#0		0's, #'s not in language.
accepted : 			1:1:1 for a:b:c. a = b and b = c so in language.

S->QT|AU|BV|HQ|a|b|#|E, Q->QT|AU|BV|HQ|a|b|#, R->AU|BV|a|b, T->HQ|#, U->RA|a, V->RB|b, A->a, B->b, H->#
rejected : aaabbb		Not a palindrome.
rejected : aabb			Not a palindrome.
rejected : ab			Not a palindrome.
rejected : abb			Not a palindrome.
rejected : aab			Not a palindrome.
rejected : aaabbbb		Not a palindrome.
rejected : abc			Not a palindrome. c's not in language.
rejected : abbcc		Not a palindrome. c's not in language.
rejected : abccc		Not a palindrome. c's not in language.
rejected : bc			Not a palindrome. c's not in language.
rejected : aabbc		Not a palindrome. c's not in language.
rejected : abcbca		Not a palindrome. c's not in language.
accepted : bab			Palindrome of a's and b's.
accepted : aaaabbbaaaa		Palindrome of a's and b's.
rejected : abaaa		Not a palindrome.
rejected : cbc			c's not in language.
accepted : abba			Palindrome of a's and b's.
accepted : bb			Palindrome of b's.
accepted : #			Empty strings separated by hash in language.
accepted : bab#aba#abba		Palindrome of a's and b's between hashes in language.
accepted : bab#b#abab		abab is not a palindrome.
accepted : bab#b#		Empty strings, palindromes of a's and b's separated by hash in language.
rejected : 00#0000		0's not in language.
rejected : 0#000#0		0's not in language.
accepted : ##			Empty strings separated by hash in language.
rejected : 0000#0#0000		0's not in language.
rejected : 0##00		0's not in language.
rejected : ##00			0's not in language.
rejected : 0#0			0's not in language.
rejected : 0#000		0's not in language.
rejected : 000#0		0's not in language.
accepted : 			Empty string is technically a palindrome.

S->TT|ZV|#, T->ZT|TZ|#, U->ZV|#, V->UW, W->ZZ, Z->0
rejected : aaabbb		a's, b's not in language.
rejected : aabb			a's, b's not in language.
rejected : ab			a's, b's not in language.
rejected : abb			a's, b's not in language.
rejected : aab			a's, b's not in language.
rejected : aaabbbb		a's, b's not in language.
rejected : abc			a's, b's, c's not in language.
rejected : abbcc		a's, b's, c's not in language.
rejected : abccc		a's, b's, c's not in language.
rejected : bc			b's, c's not in language.
rejected : aabbc		a's, b's, c's not in language.
rejected : abcbca		a's, b's, c's not in language.
rejected : bab			a's, b's not in language.
rejected : aaaabbbaaaa		a's, b's not in language.
rejected : abaaa		a's, b's not in language.
rejected : cbc			b's, c's not in language.
rejected : abba			a's, b's not in language.
rejected : bb			b's not in language.
accepted : #			S-># so in language.
rejected : bab#aba#abba		a's, b's not in language.
rejected : bab#b#abab		a's, b's not in language.
rejected : bab#b#		a's, b's not in language.
accepted : 00#0000		2 0's in first substring. 4 0's in second so in language.
accepted : 0#000#0		Fits in (0*#0*#0*) so in language.
accepted : ##			Fits in (0*#0*#0*) so in language.
accepted : 0000#0#0000		Fits in (0*#0*#0*) so in language.
accepted : 0##00		Fits in (0*#0*#0*) so in language.
accepted : ##00			Fits in (0*#0*#0*) so in language.
rejected : 0#0			1 0's in first substring. Not 2 in second so not in language.
rejected : 0#000		1 0's in first substring. Not 2 in second so not in language.
rejected : 000#0		1 0's in first substring. Not 2 in second so not in language.
rejected : 			Strings in language must have at least one hash so E not in language.

Submission
-----------------------------------------------------------------------------
Included in the submission for the following deliverables:
Source Files:
- Driver.cpp
- CYK.h
- CYK.cpp
- Lexer.h
- Lexer.c
- Token.h
- input.txt
- CFG.txt

Documentation:
- Report (pdf)
- README (.txt)
- log (.txt)	an example log from running the program with the included files
